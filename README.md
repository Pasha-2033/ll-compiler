# ll-compiler
Компилятор на питоне, собирающий код из .asm файлов в `.0.bin` и `.1.bin`.
<br/>
Т.к. процессор 64х, а разрядность logisim - 32х, появляется потребность в разделении файла `.o` (то есть результат компиляции) на 2 файла `.bin`.
<br/>
Загрузка кода производится в верхние 2 ОЗУ в схеме main соотвественно (от младшего к старшему, 0 и 1).
<br/>
Загрузка кода в нижние 2 ОЗУ осуществляется, только если есть выполнение команд по Гравардской архитектуре с чтением из ОЗУ. Для этого нужно скомпилировать отдельный код.
# Использование компилятора
Компилятор содержит 3 файла - `database.py`, `compiler.py`, `config.json`.
<br/>
Файл compiler.py парсит код и вызывает его построчное преобразование.
<br/>
Файл database.py хранит информацию о преобразовании.
<br/>
Файл config.json определяет какие файлы и с какими настройками нужно скомпилировать.
<br/>
Чтобы компилятор знал какой файл компилировать, нужно в `config.json` описать `input_files поле`, причем без формата (файл обязательно должен оканчиваться на `.asm`).
<br/>
Результат компиляции будет называться также, файлы типа `.o` и `.0.bin` и `.1.bin`. Располагается в папке описанной в `output_dir`.
<br/>
Также возможно компилировать несколько файлов одновременно.
<br/>
В будущем будет возможность использовать объедиенение файлов и их линковка.
# Синтаксис
Структура записи и чтения - построчно, формат: `flag: command0 args0; command1 args1 #comment`
<br/>
`flag` это ключевое слово (которое создается программистом), обозначающее адрес, на котором flag располагается, ограничивается `:`, не является обязательным параметром, на исполняющий код это не повлияет.
если flag не содержит набор команд после себя - то он **не существует для набора флагов** (то есть данные со значением флага/вызов прыжка по адресу флага, который не имеет команды невозможен), ошибка является вызов такого флага, но никак не его начличие - защита от сложного синтаксиса, позже будут добавлены предупреждения для такого.
<br/>
`command<n>` это операция, `args<n>` это аргументы операции, каждая операция обязяана быть отеделена от другой через точку с запятой, набор опраций на одном адресе сливаются через `XOR`.
<br/>
`#` и все, что после этого ключевого символа, будут считаться коментарием, который не будет участвовать в комиляции.
# Команды
Компилятор (`compiler.py` и `config.json`) это шаблон, который может принять любой `database.py` (вы можете подстроить под свой стиль записи `command<n>` и `args<n>`, создав свой собственный файл).
Текущие команды:
- `dq [flag/uint64_t value]` создает в коде набор данных, значение определяется как uint64_t, если аргумент н число, ведется поиск по флагам, если такой не найдет - ошибка
- `mov [uint64_t address_in_cash_L_1, cash_source source]` записывает в регистер кэша L1 по адресу address_in_cash_L_1 значение от source, source может быть:
  - `RAM` источником выступает ОЗУ (точнее кэш L2, который должен получить эти данные)
  - `ALU` источником выступает АЛУ
  - `PC` источником выступает счетчик программы, указывающий адрес сдвига от начала программы
- `unco` исполнение идет по архитектуре фон Неймана (по умолчаню - Гарвард), за такой запись обазана идти **не команда, а данные** (но можно и без dq, если а в формате генерации кода, если значение должно соотвествовать коду)
- `sel [operand reg, uint64_t index]` выбирает какие регистры подадут значения на АЛУ, index - адрес регистра в cash L1, reg - для какого операнда описание, может быть:
  - `A`
  - `B`
- `alu [operation type]` выбирает какую операцию осуществляет АЛУ:
  - `=` R = A
  - `+` R = A + B
  - `-` R = A - B
  - `*` R = A * B (схема не включена из-за возбуждения)
  - `0` R = (A * B) % len(A) (схема не включена из-за возбуждения)
  - `/` R = A / B
  - `%` R = A % B
  - `!` R = !A
  - `&` R = A & B
  - `|` R = A | B
  - `^` R = A ^ B
  - `<` R = A << B
  - `<<` R = RCL(A, B) 
  - `>` R = A >> B
  - `>>` R = RCR(A, B)
  - `b#` R = bool_alu_operation | (count_bits_equals_1(A) << 32)
<br/>
Продолжение скоро выйдет
# Пример кода на ряде Фибоначе
Продолжение скоро выйдет
